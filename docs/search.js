window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "mosa", "modulename": "mosa", "kind": "module", "doc": "<p>Simulated Annealing (SA) has been initially proposed in <a href=\"https://doi.org/10.1126/science.220.4598.671\">S. Kirkpatrick et al., \nOptimization by Simulated Annealing, Science 220, 671-680 (1983)</a> \nas a global optimization metaheuristic inspired by the metallurgical heat treatment \nprocess called <em>annealing</em>.</p>\n\n<p>We can read in the abstract of this seminal work:</p>\n\n<blockquote>\n  <p><em>There is a deep and useful connection between statistical mechanics (the \n  behavior of systems with many degrees of freedom in thermal equilibrium \n  at a finite temperature) and multivariate or combinatorial optimization \n  (finding the minimum of a given function depending on many parameters). \n  A detailed analogy with annealing in solids provides a framework for \n  optimization of the properties of very large and complex systems. This \n  connection to statistical mechanics exposes new information and provides \n  an unfamiliar perspective on traditional optimization problems and methods.</em></p>\n</blockquote>\n\n<p>SA is typically used in the optimization of combinatorial problems (e.g., traveling \nsalesman or knapsack problems), but can also be used to optimize problems where \nthe search space is continuous.</p>\n\n<p>Multi-Objective Simulation Annealing (MOSA) extends the original, single-objective \nSA algorithm to approximate the Pareto front in multi-objective optimization problems. \nA comprehensive discussion on MOSA and its algorithm variants can be found in \n<a href=\"https://doi.org/10.1155/2019/8134674\">Multi-objective Simulated Annealing: Principles and Algorithm Variants, Advances \nin Operations Research, Volume 2019, Article ID 8134674</a>.</p>\n\n<p>This library implements MOSA in Python as a probabilistic \n<a href=\"https://doi.org/10.1063/1.1699114\">Metropolis Monte Carlo algorithm</a>.</p>\n\n<h2 id=\"installation\">Installation</h2>\n\n<p>The easiest way to install <strong>MOSA</strong> is using <strong>pip</strong>:</p>\n\n<pre><code>pip install mosa\n</code></pre>\n\n<h2 id=\"getting-started\">Getting started</h2>\n\n<p>The <em>optimization problem</em> must be implemented as a Python function that takes \nthe values \u200b\u200bof a tentative solution as arguments and returns the <em>objective values</em> \nas a tuple of floating-point numbers.</p>\n\n<p>For example, the function below implements the \n<a href=\"https://github.com/rgaveiga/mosa/tree/main/examples/binh_and_korn\">Binh and Korn problem</a>:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">def</span> <span class=\"nf\">fobj</span><span class=\"p\">(</span><span class=\"n\">X1</span><span class=\"p\">:</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">X2</span><span class=\"p\">:</span> <span class=\"nb\">float</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">tuple</span><span class=\"p\">:</span>\n    <span class=\"n\">f1</span> <span class=\"o\">=</span> <span class=\"mf\">4.0</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"nb\">pow</span><span class=\"p\">(</span><span class=\"n\">X1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"nb\">pow</span><span class=\"p\">(</span><span class=\"n\">X2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n    <span class=\"n\">f2</span> <span class=\"o\">=</span> <span class=\"nb\">pow</span><span class=\"p\">((</span><span class=\"n\">X1</span> <span class=\"o\">-</span> <span class=\"mi\">5</span><span class=\"p\">),</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"nb\">pow</span><span class=\"p\">((</span><span class=\"n\">X2</span> <span class=\"o\">-</span> <span class=\"mi\">5</span><span class=\"p\">),</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n\n    <span class=\"n\">c1</span> <span class=\"o\">=</span> <span class=\"nb\">pow</span><span class=\"p\">((</span><span class=\"n\">X1</span> <span class=\"o\">-</span> <span class=\"mi\">5</span><span class=\"p\">),</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"nb\">pow</span><span class=\"p\">((</span><span class=\"n\">X2</span><span class=\"p\">),</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"n\">c2</span> <span class=\"o\">=</span> <span class=\"nb\">pow</span><span class=\"p\">((</span><span class=\"n\">X1</span> <span class=\"o\">-</span> <span class=\"mi\">8</span><span class=\"p\">),</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"nb\">pow</span><span class=\"p\">((</span><span class=\"n\">X2</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"p\">),</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">c1</span> <span class=\"o\">&gt;</span> <span class=\"mf\">25.0</span> <span class=\"ow\">or</span> <span class=\"n\">c2</span> <span class=\"o\">&lt;</span> <span class=\"mf\">7.7</span><span class=\"p\">:</span>\n        <span class=\"n\">f1</span> <span class=\"o\">=</span> <span class=\"n\">inf</span>\n        <span class=\"n\">f2</span> <span class=\"o\">=</span> <span class=\"n\">inf</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">f1</span><span class=\"p\">,</span> <span class=\"n\">f2</span>\n</code></pre>\n</div>\n\n<div class=\"alert note\">\n<em>Note</em>\n<p>MOSA treats the optimization problem as a <em>black box</em>: only the inputs and outputs\n  matter. The algorithm imposes no restrictions on what the function does with the arguments.</p>\n</div>\n\n<p>Then, the user needs to import and create an instance of the <code>mosa.mosa.Anneal</code> class:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span> <span class=\"nn\">mosa</span> <span class=\"kn\">import</span> <span class=\"n\">Anneal</span>\n\n<span class=\"n\">opt</span> <span class=\"o\">=</span> <span class=\"n\">Anneal</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n\n<p>The population from which solutions to the problem will be sampled can be defined \nas follows:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">opt</span><span class=\"o\">.</span><span class=\"n\">set_population</span><span class=\"p\">(</span><span class=\"n\">X1</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">5.0</span><span class=\"p\">),</span> <span class=\"n\">X2</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">3.0</span><span class=\"p\">))</span>\n</code></pre>\n</div>\n\n<p>It is important to make clear that <em>population</em> here does not have the same meaning \nas in techniques such as Genetic Algorithm or Particle Swarm. In the context of \nthis package, a population is the set of all elements that can be part of a solution \nto the problem.</p>\n\n<p>Furthermore, similar elements of the population (e.g., elements with the same \nmeaning, type, or boundaries) form <em>groups</em>. A group can be a discrete list \nof elements or a continuous range of numbers between a minimum and a maximum \nvalue. The same groups that make up the population will be present in the \nsolutions sampled from it.</p>\n\n<p>A number of MOSA hyperparameters can be set to control the optimization process. \nFor example, <code>mosa.mosa.Anneal.initial_temperature</code> sets the initial fictitious \ntemperature in the Monte Carlo acceptance rule, while <code>mosa.mosa.Anneal.number_of_temperatures</code> \nallows the user to determine the maximum number of temperatures in the annealing. \nSee the <code>mosa.mosa.Anneal</code> properties documentation for more details.</p>\n\n<p>The hyperparameters related to the solutions themselves are assigned using the \n<code>mosa.mosa.Anneal.set_group_params</code> or <code>mosa.mosa.Anneal.set_opt_param</code> methods, \nas seen in the following code snippet, also with the Binh and Korn problem in \nmind:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">opt</span><span class=\"o\">.</span><span class=\"n\">set_opt_param</span><span class=\"p\">(</span><span class=\"s2\">&quot;number_of_elements&quot;</span><span class=\"p\">,</span> <span class=\"n\">X1</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">X2</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">opt</span><span class=\"o\">.</span><span class=\"n\">set_opt_param</span><span class=\"p\">(</span><span class=\"s2\">&quot;mc_step_size&quot;</span><span class=\"p\">,</span> <span class=\"n\">X1</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">X2</span><span class=\"o\">=</span><span class=\"mf\">0.3</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>The optimization process starts by calling the <code>mosa.mosa.Anneal.evolve</code> method:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">opt</span><span class=\"o\">.</span><span class=\"n\">evolve</span><span class=\"p\">(</span><span class=\"n\">fobj</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>The solutions to the problem are stored in the <em>archive</em>. After the optimization \nprocess is finished, various operations can be performed on the archive, for \nexample, pruning dominated solutions that still remain using the \n<code>mosa.mosa.Anneal.prune_dominated</code> method. See the <code>mosa.mosa.Anneal</code> methods \ndocumentation for additional information.</p>\n\n<h2 id=\"usage-examples\">Usage examples</h2>\n\n<p>The Binh and Korn problem above and other examples of optimization problems that \ncan be solved with MOSA can be found in the Jupyter notebooks in the \n<a href=\"https://github.com/rgaveiga/mosa/tree/main/examples\">examples</a> directory.</p>\n"}, {"fullname": "mosa.VERSION", "modulename": "mosa", "qualname": "VERSION", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;0.8.0&#x27;"}, {"fullname": "mosa.mosa", "modulename": "mosa.mosa", "kind": "module", "doc": "<p>This module defines the <code>Anneal</code> class, which implements the MOSA algorithm.</p>\n"}, {"fullname": "mosa.mosa.Anneal", "modulename": "mosa.mosa", "qualname": "Anneal", "kind": "class", "doc": "<p>This class implements the MOSA algorithm.</p>\n"}, {"fullname": "mosa.mosa.Anneal.set_population", "modulename": "mosa.mosa", "qualname": "Anneal.set_population", "kind": "function", "doc": "<p>Sets the population.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>**groups</code>: series of key-value pairs where each key corresponds to a\ngroup in the solution and contains the data that can be used to achieve\nan optimized solution to the problem.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">groups</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mosa.mosa.Anneal.set_group_params", "modulename": "mosa.mosa", "qualname": "Anneal.set_group_params", "kind": "function", "doc": "<p>Sets the optimization parameters for the specified group in the solution.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>group</code>: group in the solution.</p>\n\n<p><code>**params</code>: names of the optimization parameters with respective values.</p>\n\n<p>They can be any of the alternatives below:</p>\n\n<ul>\n<li><p><code>number_of_elements</code></p></li>\n<li><p><code>maximum_number_of_elements</code></p></li>\n<li><p><code>distinct_elements</code></p></li>\n<li><p><code>mc_step_size</code></p></li>\n<li><p><code>change_value_move</code></p></li>\n<li><p><code>insert_or_delete_move</code></p></li>\n<li><p><code>swap_move</code></p></li>\n<li><p><code>sort_elements</code></p></li>\n<li><p><code>group_selection_weights</code></p></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">group</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">params</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mosa.mosa.Anneal.set_opt_param", "modulename": "mosa.mosa", "qualname": "Anneal.set_opt_param", "kind": "function", "doc": "<p>Sets the values of the optimization parameter for the specified solution\ngroups.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>param</code>: name of the optimization parameter.</p>\n\n<p>It must be one of the alternatives below:</p>\n\n<ul>\n<li><p><code>number_of_elements</code></p></li>\n<li><p><code>maximum_number_of_elements</code></p></li>\n<li><p><code>distinct_elements</code></p></li>\n<li><p><code>mc_step_size</code></p></li>\n<li><p><code>change_value_move</code></p></li>\n<li><p><code>insert_or_delete_move</code></p></li>\n<li><p><code>swap_move</code></p></li>\n<li><p><code>sort_elements</code></p></li>\n<li><p><code>group_selection_weights</code></p></li>\n</ul>\n\n<p><code>**groups</code>: series of key-value pairs where each key corresponds to a\ngroup in the solution to the problem.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">param</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">groups</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mosa.mosa.Anneal.evolve", "modulename": "mosa.mosa", "qualname": "Anneal.evolve", "kind": "function", "doc": "<p>Performs the optimization of the objective function.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>func</code>: objective function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"nb\">object</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mosa.mosa.Anneal.prune_dominated", "modulename": "mosa.mosa", "qualname": "Anneal.prune_dominated", "kind": "function", "doc": "<p>Returns a subset of the full or reduced solution archive containing only\nnon-dominated solutions.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>xset</code>: full or reduced solution archive.</p>\n\n<p>The default is {}, meaning the full solution archive.</p>\n\n<p><code>del_duplicated</code>: delete a solution if the objective values are strictly\nequal to the values of a previous solution.</p>\n\n<p>The default is <code>False</code>.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Solution archive with non-dominated solutions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xset</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>, </span><span class=\"param\"><span class=\"n\">del_duplicated</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "mosa.mosa.Anneal.savex", "modulename": "mosa.mosa", "qualname": "Anneal.savex", "kind": "function", "doc": "<p>Saves the solution archive into a text file in JSON format.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>xset</code>: full or reduced solution archive.</p>\n\n<p>The default is {}, meaning the full solution archive.</p>\n\n<p><code>archive_file</code>: name of the archive file.</p>\n\n<p>The default is an empty string, which means the main archive file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xset</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>, </span><span class=\"param\"><span class=\"n\">archive_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mosa.mosa.Anneal.loadx", "modulename": "mosa.mosa", "qualname": "Anneal.loadx", "kind": "function", "doc": "<p>Loads solutions from a JSON file into the solution archive.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>archive_file</code>: name of the archive file.</p>\n\n<p>The default is an empty string, which means the main archive file will\nbe used.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">archive_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mosa.mosa.Anneal.trimx", "modulename": "mosa.mosa", "qualname": "Anneal.trimx", "kind": "function", "doc": "<p>Extracts solutions where the objective values are less than or equal to\nthe thresholds.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>xset</code>: full or reduced solution archive.</p>\n\n<p>The default is {}, meaning the full solution archive.</p>\n\n<p><code>thresholds</code>: maximum values of the objective functions.</p>\n\n<p>The default is an empty list.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Solution archive with only the selected solutions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xset</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>, </span><span class=\"param\"><span class=\"n\">thresholds</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span> <span class=\"o\">|</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "mosa.mosa.Anneal.reducex", "modulename": "mosa.mosa", "qualname": "Anneal.reducex", "kind": "function", "doc": "<p>Reduces and sorts in ascending order the archive according to the selected\nobjective function.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>xset</code>: full or reduced solution archive. The default is {}, meaning the\nfull solution archive.</p>\n\n<p><code>index</code>: index of the objective function.</p>\n\n<p>The default is 0.</p>\n\n<p><code>nel</code>: number of solutions stored in the reduced solution archive.</p>\n\n<p>The default is 5.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Reduced solution archive.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xset</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">nel</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "mosa.mosa.Anneal.mergex", "modulename": "mosa.mosa", "qualname": "Anneal.mergex", "kind": "function", "doc": "<p>Merges a list of solution archives into a single solution archive.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>xset_list</code>: solution archives to be merged.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Merged solution archives.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xset_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "mosa.mosa.Anneal.copyx", "modulename": "mosa.mosa", "qualname": "Anneal.copyx", "kind": "function", "doc": "<p>Returns a copy of the solution archive.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>xset</code>: full or reduced solution archive.</p>\n\n<p>The default is {}, meaning the full solution archive.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Copy of the solution archive.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xset</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "mosa.mosa.Anneal.printx", "modulename": "mosa.mosa", "qualname": "Anneal.printx", "kind": "function", "doc": "<p>Prints the solutions in the solution archive in human readable format.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>xset</code>: full or reduced solution archive.</p>\n\n<p>The default is {}, meaning the full solution archive.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xset</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mosa.mosa.Anneal.plot_front", "modulename": "mosa.mosa", "qualname": "Anneal.plot_front", "kind": "function", "doc": "<p>Plots 2D scatter plots of selected pairs of objective values.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>xset</code>: full or reduced solution archive.</p>\n\n<p>The default is {}, meaning the full solution archive.</p>\n\n<p><code>index1</code>: index of the objective function displayed along x-axis.</p>\n\n<p>The default is 0.</p>\n\n<p><code>index2</code>: index of the objective function displayed along y-axis.</p>\n\n<p>The default is 1.</p>\n\n<p><code>file</code>: name of the image file where the plot will be saved.</p>\n\n<p>The default is <code>None</code>, which means that no figure will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">xset</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">index1</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">index2</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">file</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mosa.mosa.Anneal.print_stats", "modulename": "mosa.mosa", "qualname": "Anneal.print_stats", "kind": "function", "doc": "<p>Prints the minimum, maximum and average values of the objectives.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>xset</code>: full or reduced solution archive.</p>\n\n<p>The default is {}, meaning the full solution archive.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xset</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mosa.mosa.Anneal.population", "modulename": "mosa.mosa", "qualname": "Anneal.population", "kind": "variable", "doc": "<p>Population where each group represents the data that can be used to achieve\nan optimized solution to the problem.</p>\n", "annotation": ": dict"}, {"fullname": "mosa.mosa.Anneal.archive", "modulename": "mosa.mosa", "qualname": "Anneal.archive", "kind": "variable", "doc": "<p>Solution archive.</p>\n\n<div class=\"alert warning\">\n<em>Warning</em>\n<p>The archive should not be changed manually.</p>\n</div>\n", "annotation": ": dict"}, {"fullname": "mosa.mosa.Anneal.restart", "modulename": "mosa.mosa", "qualname": "Anneal.restart", "kind": "variable", "doc": "<p>Restarts from a previous run if a checkpoint file is available.</p>\n\n<p>The default is <code>True</code>.</p>\n", "annotation": ": bool"}, {"fullname": "mosa.mosa.Anneal.objective_weights", "modulename": "mosa.mosa", "qualname": "Anneal.objective_weights", "kind": "variable", "doc": "<p>Weights for the objectives.</p>\n\n<p>The default is [], which means the same weight (1.0) for all objectives.</p>\n", "annotation": ": list"}, {"fullname": "mosa.mosa.Anneal.initial_temperature", "modulename": "mosa.mosa", "qualname": "Anneal.initial_temperature", "kind": "variable", "doc": "<p>Initial temperature.</p>\n\n<p>The default is 1.0.</p>\n", "annotation": ": float"}, {"fullname": "mosa.mosa.Anneal.temperature_decrease_factor", "modulename": "mosa.mosa", "qualname": "Anneal.temperature_decrease_factor", "kind": "variable", "doc": "<p>Decrease factor of the temperature.</p>\n\n<p>The default is 0.9.</p>\n", "annotation": ": float"}, {"fullname": "mosa.mosa.Anneal.number_of_temperatures", "modulename": "mosa.mosa", "qualname": "Anneal.number_of_temperatures", "kind": "variable", "doc": "<p>Number of temperatures.</p>\n\n<p>The default is 10.</p>\n", "annotation": ": int"}, {"fullname": "mosa.mosa.Anneal.number_of_iterations", "modulename": "mosa.mosa", "qualname": "Anneal.number_of_iterations", "kind": "variable", "doc": "<p>Number of Monte Carlo iterations per temperature.</p>\n\n<p>The default is 1,000.</p>\n", "annotation": ": int"}, {"fullname": "mosa.mosa.Anneal.archive_size", "modulename": "mosa.mosa", "qualname": "Anneal.archive_size", "kind": "variable", "doc": "<p>Maximum number of solutions in the archive.</p>\n\n<p>The default is 1,000.</p>\n", "annotation": ": int"}, {"fullname": "mosa.mosa.Anneal.archive_file", "modulename": "mosa.mosa", "qualname": "Anneal.archive_file", "kind": "variable", "doc": "<p>Name of the archive file.</p>\n\n<p>The default is 'archive.json'.</p>\n", "annotation": ": str"}, {"fullname": "mosa.mosa.Anneal.maximum_archive_rejections", "modulename": "mosa.mosa", "qualname": "Anneal.maximum_archive_rejections", "kind": "variable", "doc": "<p>Maximum number of consecutive rejections of insertion of a solution\nin the archive.</p>\n\n<p>The default is 1,000.</p>\n", "annotation": ": int"}, {"fullname": "mosa.mosa.Anneal.alpha", "modulename": "mosa.mosa", "qualname": "Anneal.alpha", "kind": "variable", "doc": "<p>Alpha parameter.</p>\n\n<p>The default is 0.0.</p>\n", "annotation": ": float"}, {"fullname": "mosa.mosa.Anneal.number_of_elements", "modulename": "mosa.mosa", "qualname": "Anneal.number_of_elements", "kind": "variable", "doc": "<p>Number of elements for each group in the solution.</p>\n\n<p>The default is {}, which means one element for all groups in the solutions.</p>\n", "annotation": ": dict"}, {"fullname": "mosa.mosa.Anneal.maximum_number_of_elements", "modulename": "mosa.mosa", "qualname": "Anneal.maximum_number_of_elements", "kind": "variable", "doc": "<p>Maximum number of elements for each group in the solution, if the number of elements\nis variable.</p>\n\n<p>The default is {}, which means an unlimited number of elements.</p>\n", "annotation": ": dict"}, {"fullname": "mosa.mosa.Anneal.distinct_elements", "modulename": "mosa.mosa", "qualname": "Anneal.distinct_elements", "kind": "variable", "doc": "<p>Determines that an element cannot be repeated in a group in the solution.</p>\n\n<p>The default is {}, which means that repetitions are allowed.</p>\n", "annotation": ": dict"}, {"fullname": "mosa.mosa.Anneal.mc_step_size", "modulename": "mosa.mosa", "qualname": "Anneal.mc_step_size", "kind": "variable", "doc": "<p>Monte Carlo step size for each group in the solution.</p>\n\n<p>The default is {}, which means 0.1 for continuous search space and half\nthe number of elements in a population group for discrete search space.</p>\n", "annotation": ": dict"}, {"fullname": "mosa.mosa.Anneal.change_value_move", "modulename": "mosa.mosa", "qualname": "Anneal.change_value_move", "kind": "variable", "doc": "<p>Weight (non-normalized probability) to select a trial move where the value\nof a randomly selected element in a group in the solution will be modified\nas follows:</p>\n\n<ul>\n<li><p>Discrete search space: values between the solution and the population\nare exchanged.</p></li>\n<li><p>Continuous search space: the value of the solution element is randomly\nincremented/decremented.</p></li>\n</ul>\n\n<p>The default is {}, which means the weight to select this trial move is\nequal to 1.0.</p>\n", "annotation": ": dict"}, {"fullname": "mosa.mosa.Anneal.insert_or_delete_move", "modulename": "mosa.mosa", "qualname": "Anneal.insert_or_delete_move", "kind": "variable", "doc": "<p>Weight (non-normalized probability) to select a trial move where an element\nwill be inserted into or deleted from a group in the solution.</p>\n\n<p>The default is {}, which means this trial move is not allowed, i.e., the\nweight is equal to zero.</p>\n", "annotation": ": dict"}, {"fullname": "mosa.mosa.Anneal.swap_move", "modulename": "mosa.mosa", "qualname": "Anneal.swap_move", "kind": "variable", "doc": "<p>Weight (non-normalized probability) to select a trial move where elements\nwill be swaped in the solution.</p>\n\n<p>The default is {}, which means this trial move is not allowed, i.e., the\nweight is equal to zero.</p>\n", "annotation": ": dict"}, {"fullname": "mosa.mosa.Anneal.sort_elements", "modulename": "mosa.mosa", "qualname": "Anneal.sort_elements", "kind": "variable", "doc": "<p>Elements in a group in the solution will be sorted in ascending order.</p>\n\n<p>The default is {}, which means no sorting at all.</p>\n", "annotation": ": dict"}, {"fullname": "mosa.mosa.Anneal.group_selection_weights", "modulename": "mosa.mosa", "qualname": "Anneal.group_selection_weights", "kind": "variable", "doc": "<p>Selection weight for each group in the solution in a Monte Carlo iteration.</p>\n\n<p>The default value is {}, which means that all groups have the same selection\nweight, i.e., the same probability of being selected.</p>\n", "annotation": ": dict"}, {"fullname": "mosa.mosa.Anneal.track_optimization_progress", "modulename": "mosa.mosa", "qualname": "Anneal.track_optimization_progress", "kind": "variable", "doc": "<p>Tracks the optimization progress by saving the accepted objetive values\ninto a Python list.</p>\n\n<p>The default is <code>False</code>.</p>\n", "annotation": ": bool"}, {"fullname": "mosa.mosa.Anneal.accepted_objective_values", "modulename": "mosa.mosa", "qualname": "Anneal.accepted_objective_values", "kind": "variable", "doc": "<p>Accepted objective values over Monte Carlo iterations.</p>\n", "annotation": ": list"}, {"fullname": "mosa.mosa.Anneal.verbose", "modulename": "mosa.mosa", "qualname": "Anneal.verbose", "kind": "variable", "doc": "<p>Displays verbose output.</p>\n\n<p>The default is <code>False</code>.</p>\n", "annotation": ": bool"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();